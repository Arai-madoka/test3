<!DOCTYPE html>
<html>
	<head>
		<title>grid/paint</title>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">
			import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/OrbitControls.js';
			import { TubePainter } from 'https://unpkg.com/three@0.126.1/examples/jsm/misc/TubePainter.js';
			import { VRButton } from 'https://unpkg.com/three@0.126.1/examples/jsm/webxr/VRButton.js';
			import { XRControllerModelFactory } from 'https://unpkg.com/three@0.126.1/examples/jsm/webxr/XRControllerModelFactory.js';
			
			import { GUI } from 'https://unpkg.com/three@0.126.1/examples/jsm/libs/lil-gui.module.min.js';

			let camera, scene, renderer;
			let controller1, controller2;
			let controllerGrip1, controllerGrip2;

			const cursor = new THREE.Vector3();
			let raycaster;
			let controls,group;
			
			const splines = {};
			const params = {
				uniform: true,
			};

			init();
			animate();

			function init() {
				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x222222);

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 50 );
				camera.position.set( 0, 3.6, 8 );

				controls = new OrbitControls( camera, container );
				controls.target.set( 0, 1.6, 0 );
				controls.update();
				
				let g=new THREE.MeshBasicMaterial({color:0xc0c0c0});
				for(let i=0;i<6;i++){
					for(let j=1;j<2;j+=0.2){
						let grid1 =new THREE.GridHelper(1,5,g,g);
						grid1.name='grid1';
						grid1.myid=i;
						grid1.rotation.x=0;
						grid1.position.y=j;
						grid1.position.z=0;
						splines.uniform = grid1;
						scene.add(grid1);	
					}	
				}
				for(let k=0;k<6;k++){
					for(let n=-0.5;n<0.7;n+=0.2){
						let grid2 =new THREE.GridHelper(1,5,g,g);
						grid2.name='grid2';
						grid2.myid=k;
						grid2.rotation.x=Math.PI/2;
						grid2.position.y=1.5;
						grid2.position.z=n;
						//splines.uniform = grid2;
						scene.add(grid2);	
					}				
				}	
				for ( const k in splines ) {
					const spline = splines[ k ];
					scene.add( spline.mesh );
				}
				
        			const gridHelper = new THREE.GridHelper(10,5,0x222222,0x222222);scene.add(gridHelper);
				const pg = new THREE.PlaneGeometry( 10, 10 );const pm = new THREE.MeshBasicMaterial( {color: 0x778899, side: THREE.DoubleSide} );
        			const plane = new THREE.Mesh(pg, pm);plane.rotation.x =-Math.PI/2;
        			scene.add( plane );
				scene.add( new THREE.HemisphereLight( 0x888877, 0x777788 ) );

				const light = new THREE.DirectionalLight( 0xffffff, 0.5 );
				light.position.set( 0, 4, 0 );
				scene.add( light );
				//
				const painter1 = new TubePainter();
				scene.add( painter1.mesh );
				const painter2 = new TubePainter();
				scene.add( painter2.mesh );
				//
				renderer = new THREE.WebGLRenderer( { antialias: true} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );

				document.body.appendChild( VRButton.createButton( renderer ) );
				
				//gui
				const gui = new GUI();
				gui.add( params, 'uniform' ).onChange( render );
				gui.open();
				
				group = new InteractiveGroup( renderer, camera );
				scene.add(group);

				const mesh = new HTMLMesh( gui.domElement );
				mesh.position.x = - 0.75;
				mesh.position.y = 1.5;
				mesh.position.z = - 0.5;
				mesh.rotation.y = Math.PI / 4;
				mesh.scale.setScalar(2);
				group.add(mesh);

				// controllers
				function onSelectStart() {
					this.userData.isSelecting = true;
				}
				function onSelectEnd() {
					this.userData.isSelecting = false;
				}
				function onSqueezeStart() {
					this.userData.isSqueezing = true;
					this.userData.positionAtSqueezeStart = this.position.y;
					this.userData.scaleAtSqueezeStart = this.scale.x;
				}
				function onSqueezeEnd() {
					this.userData.isSqueezing = false;
				}				

				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'selectstart', onSelectStart );
				controller1.addEventListener( 'selectend', onSelectEnd );
				controller1.addEventListener( 'squeezestart', onSqueezeStart );
				controller1.addEventListener( 'squeezeend', onSqueezeEnd );
				controller1.userData.painter = painter1;
				scene.add( controller1 );

				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'selectstart', onSelectStart );
				controller2.addEventListener( 'selectend', onSelectEnd );
				controller2.addEventListener( 'squeezestart', onSqueezeStart );
				controller2.addEventListener( 'squeezeend', onSqueezeEnd );
				controller2.userData.painter = painter2;
				scene.add( controller2 );
				
				const controllerModelFactory = new XRControllerModelFactory();
				controllerGrip1 = renderer.xr.getControllerGrip(0);
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				scene.add( controllerGrip1 );
				controllerGrip2 = renderer.xr.getControllerGrip(1);
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );
				
				const geo = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 )]);
				const line = new THREE.Line( geo );
				line.name = 'line';
				line.scale.z = 5;
				controller1.add( line.clone() );
				controller2.add( line.clone() );

				raycaster = new THREE.Raycaster();

				//
				const geometry = new THREE.CylinderGeometry( 0.01, 0.02, 0.08, 5 );geometry.rotateX( - Math.PI / 2 );
				const material = new THREE.MeshStandardMaterial( { flatShading: true } );
				const mesh = new THREE.Mesh( geometry, material );
				const pivot = new THREE.Mesh( new THREE.IcosahedronGeometry( 0.01, 3 ) );
				pivot.name = 'pivot';
				pivot.position.z = - 0.05;
				mesh.add( pivot );

				controller1.add( mesh.clone() );
				controller2.add( mesh.clone() );
				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			//
			function handleController( controller ) {
				const userData = controller.userData;
				const painter = userData.painter;
				const pivot = controller.getObjectByName( 'pivot' );
				if ( userData.isSqueezing === true) {
					const delta = ( controller.position.y - userData.positionAtSqueezeStart ) * 5;
					const scale = Math.max( 0.1, userData.scaleAtSqueezeStart + delta );
					pivot.scale.setScalar( scale );
					painter.setSize( scale );
				}
				cursor.setFromMatrixPosition( pivot.matrixWorld );
				if ( userData.isSelecting === true ) {
					painter.lineTo( cursor );
					painter.update();
				} else {
					painter.moveTo( cursor );
				}
			}
			function animate() {
				renderer.setAnimationLoop( render );
			}
			function render() {
				grid2.uniform.mesh.visible = params.uniform;
				
				handleController( controller1 );
				handleController( controller2 );
				renderer.render( scene, camera );

			}
		</script>
	</body>
</html>
